# 如何直接修改数据库中的积分

本文档说明如何通过 SQLite 数据库命令直接修改用户积分。

## 前提条件

1. 有权限访问服务器上的数据库文件：`backend/database.sqlite`
2. 安装了 SQLite 命令行工具

## 方法一：使用 SQLite 命令行工具

### 1. 连接到数据库

```bash
# 在项目根目录下执行
cd backend
sqlite3 database.sqlite
```

### 2. 查看所有用户及其积分

```sql
SELECT id, username, name, studentId, points FROM users;
```

### 3. 修改指定用户的积分

#### 方法 3.1：直接设置积分值

```sql
-- 将学号为 2021001 的用户积分设置为 100
UPDATE users SET points = 100 WHERE studentId = '2021001';
```

#### 方法 3.2：增加或减少积分

```sql
-- 给学号为 2021001 的用户增加 10 分
UPDATE users SET points = points + 10 WHERE studentId = '2021001';

-- 给学号为 2021001 的用户扣除 5 分
UPDATE users SET points = points - 5 WHERE studentId = '2021001';
```

#### 方法 3.3：根据用户 ID 修改积分

```sql
-- 将 ID 为 1 的用户积分设置为 100
UPDATE users SET points = 100 WHERE id = 1;
```

### 4. 同时添加积分变更日志（推荐）

为了保持系统一致性，建议在修改积分的同时添加日志记录：

```sql
-- 开始事务
BEGIN TRANSACTION;

-- 1. 修改用户积分（给学号为 2021001 的用户增加 10 分）
UPDATE users SET points = points + 10 WHERE studentId = '2021001';

-- 2. 添加积分变更日志
-- 注意：需要先查询该用户的 id 和管理员的 id
INSERT INTO point_logs (userId, points, reason, createdBy, createdAt)
SELECT 
    u.id as userId,
    10 as points,
    '数据库直接修改' as reason,
    (SELECT id FROM users WHERE isAdmin = 1 LIMIT 1) as createdBy,
    datetime('now', 'localtime') as createdAt
FROM users u 
WHERE u.studentId = '2021001';

-- 提交事务
COMMIT;
```

### 5. 批量修改多个用户的积分

```sql
BEGIN TRANSACTION;

-- 批量修改多个用户的积分
UPDATE users SET points = points + 10 WHERE studentId IN ('2021001', '2021002', '2021003');

-- 批量添加日志记录
INSERT INTO point_logs (userId, points, reason, createdBy, createdAt)
SELECT 
    u.id,
    10,
    '批量数据库调整',
    (SELECT id FROM users WHERE isAdmin = 1 LIMIT 1),
    datetime('now', 'localtime')
FROM users u 
WHERE u.studentId IN ('2021001', '2021002', '2021003');

COMMIT;
```

### 6. 查看修改结果

```sql
-- 查看特定用户的积分
SELECT username, name, studentId, points FROM users WHERE studentId = '2021001';

-- 查看该用户的积分历史
SELECT pl.*, u.username as createdByUsername 
FROM point_logs pl 
LEFT JOIN users u ON pl.createdBy = u.id 
WHERE pl.userId = (SELECT id FROM users WHERE studentId = '2021001')
ORDER BY pl.createdAt DESC;
```

### 7. 退出 SQLite

```sql
.quit
```

## 方法二：使用 SQL 脚本文件

### 1. 创建 SQL 脚本文件

创建一个文件 `update_points.sql`：

```sql
-- 修改学号为 2021001 的用户，增加 10 分
BEGIN TRANSACTION;

UPDATE users SET points = points + 10 WHERE studentId = '2021001';

INSERT INTO point_logs (userId, points, reason, createdBy, createdAt)
SELECT 
    u.id,
    10,
    '数据库脚本调整',
    (SELECT id FROM users WHERE isAdmin = 1 LIMIT 1),
    datetime('now', 'localtime')
FROM users u 
WHERE u.studentId = '2021001';

COMMIT;

-- 查看结果
SELECT username, name, studentId, points FROM users WHERE studentId = '2021001';
```

### 2. 执行脚本

```bash
cd backend
sqlite3 database.sqlite < update_points.sql
```

## 常用查询命令

### 查看所有用户信息

```sql
SELECT id, username, name, studentId, className, points, grade 
FROM users 
ORDER BY points DESC;
```

### 查看积分排名前 10

```sql
SELECT username, name, studentId, points 
FROM users 
ORDER BY points DESC 
LIMIT 10;
```

### 查看某个用户的所有积分变更记录

```sql
SELECT 
    pl.id,
    pl.points,
    pl.reason,
    pl.createdAt,
    u.username as operator
FROM point_logs pl
LEFT JOIN users u ON pl.createdBy = u.id
WHERE pl.userId = (SELECT id FROM users WHERE studentId = '2021001')
ORDER BY pl.createdAt DESC;
```

### 统计某个用户的总积分变化

```sql
SELECT 
    u.username,
    u.name,
    u.studentId,
    u.points as current_points,
    SUM(pl.points) as total_changes,
    COUNT(pl.id) as change_count
FROM users u
LEFT JOIN point_logs pl ON u.id = pl.userId
WHERE u.studentId = '2021001'
GROUP BY u.id;
```

## 注意事项

1. **备份数据库**：在进行任何修改之前，建议先备份数据库文件：
   ```bash
   cp backend/database.sqlite backend/database.sqlite.backup
   ```

2. **事务处理**：使用 `BEGIN TRANSACTION` 和 `COMMIT` 确保数据一致性，如果出错可以使用 `ROLLBACK` 回滚。

3. **积分日志**：虽然可以只修改 `users` 表中的 `points` 字段，但强烈建议同时在 `point_logs` 表中添加记录，以保持审计追踪。

4. **管理员 ID**：在添加日志时，`createdBy` 字段需要一个管理员的 ID。上面的示例使用了 `(SELECT id FROM users WHERE isAdmin = 1 LIMIT 1)` 来自动获取第一个管理员的 ID。

5. **时间戳**：使用 `datetime('now', 'localtime')` 来记录当前本地时间。

6. **验证修改**：修改后务必查询确认修改是否成功。

7. **系统限制**：通过数据库直接修改可以绕过系统的 200 分限制，但不建议这样做，除非有特殊需求。

## 恢复备份

如果修改出错，可以恢复备份：

```bash
# 停止后端服务
# 然后恢复备份
cp backend/database.sqlite.backup backend/database.sqlite
# 重新启动后端服务
```

## 示例场景

### 场景1：重置某个用户的积分为 0

```sql
BEGIN TRANSACTION;

-- 获取当前积分（用于日志）
UPDATE users SET points = 0 WHERE studentId = '2021001';

INSERT INTO point_logs (userId, points, reason, createdBy, createdAt)
SELECT 
    u.id,
    0 - u.points as points,  -- 记录扣除的分数
    '管理员重置积分',
    (SELECT id FROM users WHERE isAdmin = 1 LIMIT 1),
    datetime('now', 'localtime')
FROM users u 
WHERE u.studentId = '2021001';

COMMIT;
```

### 场景2：给某个年级所有学生加分

```sql
BEGIN TRANSACTION;

-- 给 2024 级所有学生加 5 分
UPDATE users SET points = points + 5 WHERE grade = '2024';

-- 批量添加日志
INSERT INTO point_logs (userId, points, reason, createdBy, createdAt)
SELECT 
    u.id,
    5,
    '2024级集体加分',
    (SELECT id FROM users WHERE isAdmin = 1 LIMIT 1),
    datetime('now', 'localtime')
FROM users u 
WHERE u.grade = '2024';

COMMIT;
```

### 场景3：按班级批量修改积分

```sql
BEGIN TRANSACTION;

-- 给"计算机1班"的所有学生加 10 分
UPDATE users SET points = points + 10 WHERE className = '计算机1班';

INSERT INTO point_logs (userId, points, reason, createdBy, createdAt)
SELECT 
    u.id,
    10,
    '计算机1班集体加分',
    (SELECT id FROM users WHERE isAdmin = 1 LIMIT 1),
    datetime('now', 'localtime')
FROM users u 
WHERE u.className = '计算机1班';

COMMIT;
```

