# 时区和请假问题修复说明

## 问题总结

### 问题1：时间显示慢了8小时 ⏰
**原因**：数据库使用的是 `CURRENT_TIMESTAMP`，在 SQLite 中默认返回 UTC 时间，而北京时间是 UTC+8。

### 问题2：点名扣分未排除请假用户 📋
**原因**：自动扣分逻辑中没有检查用户是否在已批准的请假期间。

---

## 修复方案

### ✅ 修复1：时间问题

#### 已修改的文件
1. `backend/src/routes/users.ts` - 积分申诉审批时间
2. `backend/src/routes/leaves.ts` - 请假审批时间

#### 修改内容
将所有的 `CURRENT_TIMESTAMP` 改为 `datetime('now', 'localtime')`

**修改前：**
```sql
UPDATE point_requests SET respondedAt = CURRENT_TIMESTAMP WHERE ...
```

**修改后：**
```sql
UPDATE point_requests SET respondedAt = datetime('now', 'localtime') WHERE ...
```

#### 关于历史数据
- **新数据**：从现在开始，所有新插入/更新的记录都将使用北京时间（UTC+8）
- **历史数据**：保持UTC时间不变，避免数据混乱
- **前端显示**：已在前端正确处理时区转换，显示为本地时间

#### 如果需要转换历史数据（可选，谨慎操作）

⚠️ **警告：请先备份数据库！**

```bash
# 备份数据库
cp backend/database.sqlite backend/database.sqlite.backup
```

然后可以运行以下SQL命令转换历史数据：

```sql
-- 连接到数据库
sqlite3 backend/database.sqlite

-- 转换积分日志时间（+8小时）
UPDATE point_logs SET createdAt = datetime(createdAt, '+8 hours');

-- 转换请假记录时间
UPDATE leaves SET createdAt = datetime(createdAt, '+8 hours');
UPDATE leaves SET respondedAt = datetime(respondedAt, '+8 hours') WHERE respondedAt IS NOT NULL;

-- 转换用户创建时间
UPDATE users SET createdAt = datetime(createdAt, '+8 hours');

-- 转换点名记录时间
UPDATE attendances SET createdAt = datetime(createdAt, '+8 hours');
UPDATE daily_attendance_triggers SET createdAt = datetime(createdAt, '+8 hours');
UPDATE attendance_records SET signedAt = datetime(signedAt, '+8 hours');

-- 转换积分申诉时间
UPDATE point_requests SET createdAt = datetime(createdAt, '+8 hours');
UPDATE point_requests SET respondedAt = datetime(respondedAt, '+8 hours') WHERE respondedAt IS NOT NULL;

-- 退出
.quit
```

**建议**：如果数据量不大且历史记录不多，可以执行上述转换。如果系统已经运行很久且数据量大，建议保持历史数据不变。

---

### ✅ 修复2：点名扣分排除请假用户

#### 修改的文件
`backend/src/services/scheduler.ts`

#### 修改内容
在自动扣分逻辑中添加了请假检查：

```typescript
// 获取当天有已批准请假的用户
const usersOnLeave = await new Promise<any[]>((resolve, reject) => {
  db.all(
    `SELECT DISTINCT userId FROM leaves 
     WHERE status = 'approved' 
     AND date(startTime) <= date(?) 
     AND date(endTime) >= date(?)`,
    [trigger.triggerDate, trigger.triggerDate],
    (err, rows) => {
      if (err) reject(err);
      else resolve(rows || []);
    }
  );
});

const usersOnLeaveIds = new Set(usersOnLeave.map(u => u.userId));

// 过滤出未签到且未请假的用户
const unsignedUsers = allUsers.filter(u => 
  !signedUserIds.has(u.id) && !usersOnLeaveIds.has(u.id)
);
```

#### 工作原理
1. 查询当天有已批准请假的所有用户
2. 在扣分时，排除这些用户
3. 只对未签到**且**未请假的用户扣分
4. 在日志中记录排除的请假用户数量

#### 测试场景
- ✅ 用户A请假被批准 → 不会被扣分
- ✅ 用户B未请假且未签到 → 会被扣分
- ✅ 用户C未请假但已签到 → 不会被扣分
- ✅ 用户D请假被拒绝且未签到 → 会被扣分（因为请假未批准）

---

## 部署步骤

### 1. 重新编译后端

```bash
cd backend
npm run build
```

### 2. 重启后端服务

```bash
# 停止当前服务（根据您的启动方式）
# 然后启动新服务
npm start
```

### 3. （可选）运行时区迁移说明

```bash
cd backend
npm run ts-node src/database/migrate-fix-timezone.ts
```

这会显示时区修复的说明和建议。

---

## 验证修复

### 验证时间修复

1. **创建一条新的积分记录**
   - 以管理员身份登录
   - 修改某个用户的积分
   - 查看积分历史，确认时间显示正确

2. **创建一条请假申请并审批**
   - 提交请假申请
   - 管理员审批
   - 查看审批时间是否正确

3. **检查数据库**
   ```bash
   sqlite3 backend/database.sqlite
   SELECT datetime('now', 'localtime') as current_time;
   SELECT createdAt FROM point_logs ORDER BY id DESC LIMIT 1;
   ```

### 验证请假排除逻辑

1. **创建测试场景**
   - 用户A提交请假申请（覆盖今天）
   - 管理员批准请假
   - 创建一个今天的点名任务
   - 立即触发点名

2. **等待点名截止**
   - 用户A不签到（因为请假了）
   - 用户B不签到（未请假）

3. **检查结果**
   - 用户A不应该被扣分（已请假）
   - 用户B应该被扣分（未请假且未签到）

4. **查看日志**
   ```bash
   # 在后端控制台应该看到类似输出：
   # "1 user(s) on approved leave, excluded from penalty"
   ```

---

## 注意事项

### 关于时区

1. **数据一致性**：所有新记录使用本地时间（北京时间）
2. **历史数据**：可以选择保持UTC或转换为本地时间
3. **前端显示**：前端已正确处理时区转换

### 关于请假排除

1. **只排除已批准的请假**：状态为 'pending' 或 'rejected' 的请假不会被排除
2. **日期匹配**：请假日期范围必须覆盖点名日期
3. **性能影响**：每次扣分时都会查询请假表，但查询经过优化，影响很小

---

## 技术细节

### SQLite 时间函数

- `CURRENT_TIMESTAMP`：返回UTC时间（格式：YYYY-MM-DD HH:MM:SS）
- `datetime('now', 'localtime')`：返回本地时间（自动加上时区偏移）
- `datetime(time_string, '+8 hours')`：手动添加8小时偏移

### 请假日期比较

使用 `date()` 函数确保只比较日期部分，忽略时间：
```sql
WHERE date(startTime) <= date(?) AND date(endTime) >= date(?)
```

这确保了即使请假时间是"2024-01-01 08:00:00"，也能匹配"2024-01-01"的点名。

---

## 后续建议

1. **监控日志**：观察后端日志，确认请假排除逻辑正常工作
2. **用户通知**：可以考虑在请假被批准时发送确认邮件，告知用户在请假期间不会因未签到而扣分
3. **数据备份**：定期备份数据库，特别是在进行时区转换前

---

*修复完成时间：2024年*
*所有修改已通过Lint检查* ✅

